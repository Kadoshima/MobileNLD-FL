# 動的調整システム（Comprehensive Dynamic Adjustment System）

## 概要
Q15固定小数点演算の数値不安定性を解決するため、信号の動的レンジをリアルタイムに監視・調整するシステム。

## システムアーキテクチャ

### Monitor → Scale → Process フロー
1. **Monitor**: 信号の統計情報（最大値、最小値、分散）を監視
2. **Scale**: オーバーフロー/アンダーフローリスクに基づきスケーリング
3. **Process**: 調整された信号で非線形解析を実行

## 主要コンポーネント

### 1. DynamicRangeMonitor
```swift
enum RangeStatus {
    case overflowRisk(scale: Float)    // >0.9
    case nearLimit(currentRange: Float) // >0.7
    case optimal(currentRange: Float)   // 0.1-0.7
    case underflowRisk(scale: Float)    // <0.1
}
```

### 2. AdaptiveScalingEngine
- **多段階スケーリング**: 各処理段階で最適なスケール適用
- **履歴管理**: 逆変換のためのスケール情報記録
- **誤差補償**: スケーリングによる精度劣化を補正

### 3. CrossStageCoordinator
処理段階間でのスケール情報を調整し、累積効果を管理。

## ステージ別スケーリング戦略

### phase_space（位相空間）
- スケール係数: 0.8
- 理由: 埋め込みによる値の増幅に備える

### distance（距離計算）
- スケール係数: 0.6-0.7
- 理由: 二乗演算による急激な増大を防ぐ

### lyapunov（リアプノフ指数）
- スケール係数: 0.9（最小0.5）
- 理由: 微小差分の精度を保持

## 実装での課題と現状

### オーバーヘッドの原因
1. **頻繁な範囲チェック**: 全要素をループで確認
2. **Float変換**: vDSP使用時のInt16↔Float変換
3. **履歴管理**: ScalingRecordの保存と検索

### 最適化の余地
1. **バッチ処理**: 個別スケーリングではなく一括処理
2. **適応的頻度**: 常時ではなく必要時のみスケーリング
3. **SIMD統合**: スケーリング自体もSIMD化

## なぜ期待ほど効果的でなかったか

### 理論と実装のギャップ
- 理論: オーバーフロー防止で精度向上
- 実装: オーバーヘッドが処理時間を増大

### データ特性の影響
- Rösslerシステムは比較的安定した範囲
- 実際のオーバーフローリスクは限定的
- スケーリングの恩恵が小さい

### SIMD最適化との相性
- SIMD: データ並列性を最大化
- 動的調整: 条件分岐とメモリアクセス増加
- 両者の組み合わせが最適ではない可能性