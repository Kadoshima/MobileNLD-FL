# 最適化された実装計画

## 🎯 ゴール
**2025年9月のIEICE ComEX投稿に向けた効率的実装・実験**

## 🎯 優先事項（批判を受けて改訂）
1. **mJ/判定指標の実装と測定**
2. **BLE実測値（ATT_MTU, 接続間隔）の明記**
3. **最小限の実装（訪欲・線形割当）**
4. **特徴量のみのBLE送信**

---

## Week 1: 実装スプリント (12/10-16)

### Phase 1: 文献レビュー（簡略化）
**目標**: 3系統×各1本に厳選

- [ ] **TinyML/エッジHAR**: Zhou et al. 2025
- [ ] **省電力HAR総説**: Contoli et al. 2024
- [ ] **階層推論**: Dentamaro et al. 2024
- [ ] この3本のみに絞ってRelated Workを構成

### Day 1-2: 環境構築とBLE通信確立
**目標**: M5Stack×3とiPhoneの基本通信確立

#### Day 1 (12/10午後-12/11)
- [ ] Arduino IDE環境構築
- [ ] M5Stack Core2ライブラリインストール
- [ ] BLEサンプルコード動作確認
- [ ] IMUセンサーデータ取得テスト

**確認コード**:
```cpp
// M5Stack_sensor.ino
#include <M5Core2.h>
#include <BLEDevice.h>
#include <BLEServer.h>

#define SERVICE_UUID "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"

void setup() {
    M5.begin();
    M5.IMU.Init();
    
    BLEDevice::init("M5Stack_HAR_1");
    BLEServer *pServer = BLEDevice::createServer();
    // BLE setup continues...
}
```

#### Day 2 (12/12)
- [ ] iPhone側BLE受信アプリ実装
- [ ] リアルタイムデータ可視化
- [ ] 3台のM5Stack識別システム
- [ ] データ同期メカニズム実装

**SwiftUIアプリ基本構造**:
```swift
// ContentView.swift
import SwiftUI
import CoreBluetooth

struct SensorDataView: View {
    @StateObject var bleManager = BLEManager()
    // Real-time visualization
}
```

### Day 3-4: TensorFlow Lite Micro実装
**目標**: エッジデバイス上での推論環境構築

#### Day 3 (12/12)
- [ ] TFLite Micro環境セットアップ
- [ ] 2クラスモデル（動作/静止）作成
- [ ] モデル量子化とサイズ最適化（<20KB）
- [ ] M5Stackへのデプロイ

**モデル訓練スクリプト**:
```python
# train_lightweight_model.py
import tensorflow as tf

def create_2class_model():
    model = tf.keras.Sequential([
        tf.keras.layers.Dense(16, activation='relu', input_shape=(6,)),
        tf.keras.layers.Dense(8, activation='relu'),
        tf.keras.layers.Dense(2, activation='softmax')
    ])
    return model

# Quantization for TFLite Micro
converter = tf.lite.TFLiteConverter.from_keras_model(model)
converter.optimizations = [tf.lite.Optimize.DEFAULT]
tflite_model = converter.convert()
```

#### Day 4 (12/13)
- [ ] 8クラスモデル作成（UCI HAR使用）
- [ ] モデル精度検証
- [ ] 推論時間測定
- [ ] メモリ使用量最適化

### Day 5-7: 分散システム統合
**目標**: 3台協調動作の実現

#### Day 5 (12/14)
- [ ] デバイス間タスク分割ロジック
- [ ] 動的負荷分散アルゴリズム実装
- [ ] バッテリー残量監視システム
- [ ] フェイルオーバー機構

**簡略化された負荷分散（訪欲法）**:
```python
# simple_load_balancer.py
class SimpleLoadBalancer:
    def __init__(self):
        self.devices = {'M5_1': 100, 'M5_2': 100, 'M5_3': 100}  # Battery %
        self.reassign_interval = 2  # seconds
        self.hysteresis = 10  # % threshold to prevent oscillation
    
    def assign_task(self):
        # Greedy: assign to highest battery device
        return max(self.devices, key=self.devices.get)
```

#### Day 6-7 (12/15-16)
- [ ] End-to-endシステムテスト
- [ ] レイテンシ最適化
- [ ] エラーハンドリング実装
- [ ] デバッグとパフォーマンスチューニング

#### Day 7 (12/16): バッファ日
**目標**: Week 1の遅延対応と調整
- [ ] 未完了タスクの完了
- [ ] システム統合テスト
- [ ] 次週準備
- [ ] ドキュメント整理

---

## Week 2: 実験と検証 (12/17-23)

### Day 8-10: データ収集
**目標**: 実験用データセット構築

#### Day 8 (12/17)
- [ ] UCI HARデータセットダウンロード・前処理
- [ ] データ収集プロトコル策定
- [ ] 実験環境セットアップ
- [ ] キャリブレーション実施

#### Day 9-10 (12/18-19)
- [ ] 独自データ収集（3人×8動作×100サンプル）
- [ ] データラベリング
- [ ] 品質チェック
- [ ] 訓練/検証/テストセット分割

**動作クラス定義**:
```
1. Walking
2. Walking Upstairs
3. Walking Downstairs
4. Sitting
5. Standing
6. Laying
7. Running
8. Jumping
```

### Day 11-12: mJ/判定測定
**目標**: 主要指標の定量化

#### Day 11 (12/20)
- [ ] USB電流計で実測
- [ ] **mJ/判定計算**：(電流×電圧×時間)/判定回数
- [ ] 3台総和と最小バッテリー端末単体の両方測定

**最小限の測定セット**:
```
1. 提案手法（動的＋階層ゲート）: 5分×3回
2. 静的割当: 5分×3回
3. スマホ単独: 5分×3回
4. M5Stack単独: 5分×3回
```

#### BLE実測パラメータ記録
- [ ] **ATT_MTU**: 185バイト（実測）
- [ ] **接続間隔**: 15-20ms（実測）
- [ ] **特徴量サイズ**: 20-50バイト
- [ ] p50/p99レイテンシ測定

#### Day 12 (12/21)
- [ ] バッテリー持続時間テスト
- [ ] 温度上昇測定
- [ ] 長時間稼働テスト
- [ ] 異常値の分析

### Day 13-14: 精度評価
**目標**: 提案手法の認識精度検証

#### Day 13 (12/22)
- [ ] Leave-one-out交差検証
- [ ] 混同行列作成
- [ ] クラス別精度分析
- [ ] エラー分析

#### Day 14 (12/22-23)
- [ ] リアルタイム性能評価
- [ ] スループット測定
- [ ] 統計的有意性検定
- [ ] 比較実験まとめ

#### Day 15 (12/23午後): バッファ日
**目標**: Week 2の実験完了確認と調整
- [ ] 実験データの検証
- [ ] 追加実験の実施（必要に応じて）
- [ ] 結果の整理
- [ ] 論文執筆準備

---

## Week 3: 論文執筆 (12/24-30)

### Day 15-17: 本文執筆
**目標**: IEICEレター4ページ完成

#### Day 15 (12/24)
- [ ] Introduction執筆（0.5ページ）
- [ ] Related Work執筆（0.5ページ）

#### Day 16 (12/25)
- [ ] Proposed Method執筆（1.5ページ）
  - システムアーキテクチャ図作成
  - アルゴリズム擬似コード

#### Day 17 (12/26)
- [ ] Experiments執筆（1ページ）
- [ ] Results執筆（0.5ページ）

### Day 18-19: 図表作成
**目標**: 説得力のあるビジュアル

#### Day 18 (12/27)
- [ ] システム構成図
- [ ] 消費電力比較グラフ
- [ ] 精度-電力トレードオフ図
- [ ] 混同行列ヒートマップ

#### Day 19 (12/28)
- [ ] レイテンシ分析グラフ
- [ ] デバイス間通信フロー図
- [ ] 実験セットアップ写真
- [ ] 表のフォーマット調整

### Day 20-21: 推敲と最終化
**目標**: 投稿準備完了

#### Day 20 (12/29)
- [ ] 全体推敲
- [ ] 英文校正
- [ ] 参考文献整理
- [ ] フォーマット確認

#### Day 21 (12/30)
- [ ] 共著者レビュー
- [ ] 最終修正
- [ ] 投稿システム登録
- [ ] バックアップ作成

---

## 📊 成功指標（KPI）

### 優先指標（改訂版）
- [ ] **mJ/判定**: 40-60%削減（主要指標）
- [ ] **p99レイテンシ**: <100ms（BLE制約下）
- [ ] **精度（8クラス）**: 85-92%維持
- [ ] **モデルサイズ**: <50KB

### 実装指標
- [ ] BLE通信成功率: >99%
- [ ] システム稼働時間: >24時間
- [ ] デバイス間同期精度: <10ms

### 論文指標
- [ ] ページ数: 4ページ以内
- [ ] 図表数: 5-6個
- [ ] 参考文献: 15-20本
- [ ] 新規性の明確な記述

---

## 🚨 リスクと対策

### Week 1リスク
- **BLE接続不安定**
  → 対策: 有線シリアル通信でバックアップ

- **メモリ不足**
  → 対策: モデル圧縮、特徴量削減

### Week 2リスク
- **データ収集遅延**
  → 対策: UCI HARのみで進行

- **電力測定機器故障**
  → 対策: ソフトウェアベース推定

### Week 3リスク
- **執筆遅延**
  → 対策: テンプレート事前準備

---

## 📝 日次チェックリスト

### アブレーション実験（必須）
- [ ] **動的割当 ON/OFF**: 効果測定
- [ ] **階層ゲーティング ON/OFF**: 効果測定

### 結果の可視化（最小限）
- [ ] **図1枚**: Pareto曲線（mJ/判定 vs 精度 vs p99レイテンシ）
- [ ] **表1枚**: BLE通信パラメータと測定条件

### 週次レビュー
- [ ] KPI達成度確認
- [ ] スケジュール調整
- [ ] リスク評価
- [ ] 成果物バックアップ

---

## 🎯 最終成果物

1. **ソースコード**
   - M5Stack firmware (C++)
   - iPhone app (Swift)
   - ML training scripts (Python)

2. **実験データ**
   - センサーデータ
   - 消費電力ログ
   - 精度評価結果

3. **論文**
   - IEICEレター原稿
   - 補足資料
   - プレゼン資料

4. **デモ**
   - 動作デモ動画
   - システム説明資料

---
*Last Updated: 2024-12-10*
*Target: IEICE ComEX (September 2025)*
*Focus: mJ/decision metric with minimal implementation*